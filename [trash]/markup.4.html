<!DOCTYPE html>
<html>

<head>
  <title>SMotaal's Markup</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0, viewport-fit=cover">
  <link rel="stylesheet" href="./styles.css" />

  <template id="source-header">
    <header>
      <div id="summary">
        <span title="source">#<span id="source"></span><time></time></span>
      </div>
      <div id="details">
        <span title="render"><span id="render"></span><time></time></span>
        <span title="repeats"><span id="repeats"></span><time></time></span>
        <span title="iterations"><span id="iterations"></span><time></time></span>
      </div>
      <div id="controls">
        <span>
          <a id="rerender" title="Rerender" onclick="click()"><i icon>&#x27f3;</i></a>
          <a id="contrast" title="Dark/Light Mode" onclick="click()"><i icon>&#x263D;</i></a>
        </span>
      </div>
    </header>
  </template>

  <links-group id="samples">
    <!-- Source Code Samples -->
    <links-group id="markup">
      <!-- Markup -->
      <link id="markup" rel="prefetch" href="./lib/markup.js">
      <link id="markup-dom" rel="prefetch" href="./lib/markup-dom.js">
      <link id="markup-modes" rel="prefetch" href="./lib/markup-modes.js">
    </links-group>
    <links-group id="examples">
      <!-- Examples -->
      <link id="leo-routes" rel="prefetch" href="./samples/pholio-routes-profile.js">
      <link id="punctuation" rel="prefetch" href="./samples/punctuation.js">
    </links-group>
    <links-group id="vendor">
      <!-- Third-party -->
      <link id="acorn" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/acorn/5.7.3/acorn_loose.es.js">
      <link id="esprima" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/esprima/2.7.3/esprima.js">
      <link id="babel" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.js">
      <link id="babel-min" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.min.js">
      <link id="popper" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/esm/popper.js">
      <link id="xregexp" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.js">
      <link id="xregexp-min" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.min.js">
    </links-group>
  </links-group>
</head>

<body>
  <pre id="source-code" hidden>
    <script>
      {
        const element = document.currentScript.parentElement;

        // TODO: Add support for @media (prefers-dark-mode) when it lands
        const prefersDarkInterface = matchMedia('prefers-dark-interface');

        (
          matchMedia('prefers-dark-interface').matches &&
          !element.classList.add('prefers-dark-mode') ||
          localStorage.darkMode
        ) && element.classList.add('dark-mode');

        element.hidden = false;

        navigator.serviceWorker && (async () => (await navigator.serviceWorker.getRegistrations()).forEach(registration => registration.unregister))();
      }
    </script>
  </pre>

  <script type="module" defer>
    import markup from './markup.js';

    const defaults = {
      repeats: 1,
      iterations: 0,
      sourceURL: './lib/markup.js',
      sourceType: undefined,
      element: 'pre#source-code',
      headerTemplate: 'template#source-header',
    }

    const options = {
      ... defaults,
      // iterations: 500,
      // repeats: 0,
    };

    const sourceCodeElement = document.querySelector(options.element);
    const sourceHeaderTemplate = document.querySelector(options.headerTemplate);

    sourceHeaderTemplate && (sourceHeaderTemplate.selectors = {
      'source-span': '#source',
      'source-time': '#source + time',
      'render-span': '#render',
      'render-time': '#render + time',
      'repeats-span': '#repeats',
      'repeats-time': '#repeats + time',
      'iterations-span': '#iterations',
      'iterations-time': '#iterations + time',
      'rerender-button': '#rerender[onclick]',
      'contrast-button': '#contrast[onclick]',
    });

    const loadFromURL = async (specifier) => {
      let fetched, response, result;
      const url = `${new URL(specifier, location)}`;
      const source = {specifier, url};
      try {
        source.response = await fetch(url);
        source.sourceText = await source.response.text();
        return result = source;
      } finally {
        result || console.warn('Failed to load source from "%s" — %o', specifier, source);
      }
    }

    const nextFrame = () => new Promise(ƒ => requestAnimationFrame(ƒ));

    const renderMarkup = (sourceText, markupOptions) => (
      markupOptions.fragment || (markupOptions.fragment = document.createDocumentFragment()),
      markup.render(sourceText, markupOptions)
    );

    const renderHeader = ({
      template = sourceHeaderTemplate,
      selectors = template.selectors,
      rerender = console.warn,
    }) => {
      /** @type {HTMLElement} */
      const header = template.content.firstElementChild.cloneNode(true);

      header.elements = {};

      if (selectors) {
        for (const [id, selector] of Object.entries(selectors)) {
          header.elements[id] = selector && header.querySelector(selector) || undefined;
        }
      }

      header.elements['rerender-button'] && (header.elements['rerender-button'].click = rerender);
      header.elements['contrast-button'] && (header.elements['contrast-button'].click = async () => {
        const parent = header.parentElement;
        if (parent) {
          // if (!parent.style.transition) {
          //   parent.style.transition = 'background 375ms ease-in-out';
          //   await nextFrame();
          // }
          parent.classList.toggle('dark-mode')
            ? (localStorage.darkMode = true)
            : (delete localStorage.darkMode);
          // setTimeout(() => parent.style.transition = undefined, 500);
        }
      });


      header.status = (name, value) => {
        header.status[name] === (header.status[name] = value);
        const element = header.elements[`${name}-span`];
        const text = `${value || ''}`;
        element ? element.innerText = text : text && console.info('[%s] %o', name, value);
      }

      header.timing = (name, value) => {
        header.timing[name] === (header.timing[name] = value);
        const status = header.status[name] || 'done';
        const element = header.elements[`${name}-time`];
        const text = value === true ? '…' : value >= 0 ? `${value} ms` : '';
        element ? element.innerText = text : text && console.info('[%s] %o — %o', name, status, value);
      }

      header.stats = ({name, status, time}) => {
        !name || (
          status === undefined || header.status(name, status),
          time === undefined ||  header.timing(name, time)
        );
      }

      header.reset = () => {
        for (const [id, element] of Object.entries(header.elements)) {
          /-time|-span/.test(id) && (element.innerText = '');
        }
      }

      return header;
    }

    const round = (value, significance = 1) =>
      Math.round((significance = 10 ** (~~significance || 0)) * value) / significance;

    const renderFromURL = async (specifier, sourceType) => {
      let returned, fragment, render;

      const {repeats = 1, iterations = 0} = options;
      const container = sourceCodeElement;
      const now = options.now || Date.now;

      const header = renderHeader({rerender: () => render()});
      const {timing, status} = header;
      const time = async (name, executor) => {
        let start, result, end, elapsed;
        start = now();
        result = await executor();
        end = now();
        elapsed = end - start;
        timing && timing(name, round(elapsed));
        return {name, executor, start, result, end, elapsed};
      }

      container.innerHTML = '';
      container.appendChild(header);
      const code = container.appendChild(document.createElement('slot'));

      try {

        await nextFrame(header.status('source', `${specifier}`), header.timing('source', true));
        const { result: {sourceText, response} } = await time('source', () => loadFromURL(specifier));
        sourceType = `${sourceType || response.headers.get('Content-Type') || options.sourceType}`.replace(/^(?:.*?\/)?(\w+).*$/, '$1').toLowerCase();
        sourceType in markup.modes || (sourceType = 'markup');
        const markupOptions = {sourceType};
        header.status('source', `${specifier}`);

        fragment = code;

        render = async () => {
          code.innerText = '';
          await nextFrame();

          header.stats({name: 'render', status: '', time: -1});
          header.stats({name: 'repeats', status: '', time: -1});
          header.stats({name: 'iterations', status: '', time: -1});

          if (repeats > 0) {
            await nextFrame(header.stats({name: 'render', status: `${sourceType}`, time: true}));
            time('render', ƒ => {
              fragment = renderMarkup(sourceText, markupOptions);
              code.appendChild(fragment);
            });
            header.status('render', `${sourceType}`);
          }

          if (repeats > 1) {
            await nextFrame(header.stats({name: 'repeats', status: `⁎${repeats}`, time: true}))
            time('repeats', async ƒ => {
              for (let n = repeats; --n; code.appendChild(renderMarkup(sourceText, markupOptions)));
              //  n % 10 || await nextFrame();
            });
            header.status('repeats', `⁎${repeats}`);
          }

          if (iterations > 0) {
            await nextFrame(header.stats({name: 'iterations', status: `⁑${iterations}`, time: true}))

            time('iterations', async ƒ => {
              for (let n = iterations; n--; [... markup.tokenize(sourceText, markupOptions)]);
            });

            header.status('iterations', `⁑${iterations}`);
          }

          return fragment;
        };

        fragment = await render();

        return returned = fragment;
      } finally {
        !returned && (container.innerText = 'Failed!');
      }
    }

    const renderFromHash = (hash = location.hash) => {
      const match = /#(.*?)(?:\!([a-z]+))?(?:\*(\d+))?(?:\*{2}(\d+))?$/.exec(hash);
      const [,specifier, type, repeats = defaults.repeats, iterations = defaults.iterations] = match || '';
      const sourceType = type || undefined;
      options.repeats = repeats >= 0 ? parseInt(repeats) : defaults.repeats;
      options.iterations = iterations >= 0 ? parseInt(iterations) : defaults.iterations;
      const link = /^\w[\w\-]*$/.test(specifier) && document.querySelector(`link#${specifier}`);
      const source = link && link.href || specifier || options.source;
      source && (options.source = source);
      // console.log(match, {specifier, link, source, type, repeats, iterations});
      specifier && renderFromURL(source, sourceType);
    };

    window.addEventListener('hashchange', () => renderFromHash());

    requestAnimationFrame(() => renderFromHash(location.hash !== '#' && location.hash || `#${defaults.sourceURL}`));

</script>
</body>

</html>
