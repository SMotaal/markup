<!DOCTYPE html>
<html>

<head>
  <title>SMotaal's Markup</title>
  <meta charset="utf-8">
  <!-- <base href=".."> -->
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0, viewport-fit=cover">
  <link rel="stylesheet" href="styles.css" />

  <template id="source-header">
    <header>
      <div id="summary">
        <span title="source">#<span id="source"></span><time></time></span>
      </div>
      <div id="details">
        <span title="type"><b><span id="source-type"></b></span></span>
        <span title="repeats"><span id="repeats"></span><time></time></span>
        <span title="iterations"><span id="iterations"></span><time></time></span>
        <!-- <span title="render"><span id="render"></span><time></time></span> -->
      </div>
      <div id="controls">
        <span>
          <a id="rerender" title="Rerender" onclick="click()"><i icon>&#x27f3;</i></a>
          <a id="contrast" title="Dark/Light Mode" onclick="click()"><i icon>&#x263D;</i></a>
        </span>
      </div>
    </header>
  </template>
  <template>
    <custom-element custom-attribute=true namespace:attribute=false></custom-element>
  </template>

  <!-- <script src="service-worker-client.js"></script> -->
</head>

<body>
  <!-- <script>new Worker('./rollup-worker.js');</script> -->
  <pre id="source-code" class="markup-container" hidden>
    <script>
      {
        const defaults = { darkMode: true };
        const element = document.currentScript.parentElement;

        // TODO: Add support for @media (prefers-dark-mode) when it lands
        const prefersDarkInterface = matchMedia('prefers-dark-interface');

        (
          matchMedia('prefers-dark-interface').matches &&
          !element.classList.add('prefers-dark-mode') ||
          localStorage.darkMode ||
          defaults.darkMode
        ) && element.classList.add('dark-mode');

        element.hidden = false;

        // navigator.serviceWorker && (async () => (await navigator.serviceWorker.getRegistrations()).forEach(registration => registration.unregister))();
      }
    </script>
  </pre>

  <script type="module">
    import markup from './lib/markup.js';

    const defaults = {
      repeats: 1,
      iterations: 1,
      sourceURL: './lib/markup-modes.js',
      sourceType: undefined,
      element: 'pre#source-code',
      headerTemplate: 'template#source-header',
    }
    const hashMatcher = /#(.*?)(?:\!([a-z]+)|\!.*?)?(?:\*(?!\*)(\d+))?(?:\*{2}(\d+))?$/;
    const options = Object.create(defaults);
    const sourceCodeElement = document.querySelector(options.element);
    const sourceHeaderTemplate = document.querySelector(options.headerTemplate);

    const loadFromURL = async (specifier) => {
      let fetched, response, result;
      const url = `${new URL(specifier, location)}`;
      const source = { specifier, url };
      try {
        source.response = await fetch(url);
        source.sourceText = await source.response.text();
        return result = source;
      } finally {
        result || console.warn('Failed to load source from "%s" — %o', specifier, source);
      }
    }

    const nextFrame = () => new Promise(ƒ => requestAnimationFrame(ƒ));

    const timeDelay = delay => new Promise(ƒ => setTimeout(ƒ, delay));

    const renderMarkup = async (sourceText, markupOptions) => (
      markupOptions.fragment || (markupOptions.fragment = document.createDocumentFragment()),
      await markup.render(sourceText, markupOptions)
    );

    const renderHeader = ({
      template = sourceHeaderTemplate,
      selectors = template.selectors,
      rerender = console.warn,
    }) => {
      /** @type {HTMLElement} */
      const header = template.content.firstElementChild.cloneNode(true);

      header.elements = {};

      if (selectors) {
        for (const [id, selector] of Object.entries(selectors)) {
          header.elements[id] = selector && header.querySelector(selector) || undefined;
        }
      }

      header.elements['rerender-button'] && (header.elements['rerender-button'].click = rerender);
      header.elements['contrast-button'] && (header.elements['contrast-button'].click = async () => {
        const parent = header.parentElement;
        if (parent) {
          parent.classList.toggle('dark-mode')
            ? (localStorage.darkMode = true)
            : (delete localStorage.darkMode);
        }
      });


      header.status = (name, value) => {
        header.status[name] === (header.status[name] = value);
        const element = header.elements[`${name}-span`];
        const text = `${value || ''}`;
        element ? element.innerText = text : text && console.info('[%s] %o', name, value);
      }

      header.timing = (name, value) => {
        header.timing[name] === (header.timing[name] = value);
        const status = header.status[name] || 'done';
        const element = header.elements[`${name}-time`];
        const text = value === true ? '…' : value >= 0 ? `${value} ms` : '';
        element ? element.innerText = text : text && console.info('[%s] %o — %o', name, status, value);
      }

      header.stats = ({ name, status, time }) => {
        !name || (
          status === undefined || header.status(name, status),
          time === undefined || header.timing(name, time)
        );
      }

      header.reset = () => {
        for (const [id, element] of Object.entries(header.elements)) {
          /-time|-span/.test(id) && (element.innerText = '');
        }
      }

      return header;
    }

    const round = (value, significance = 1) =>
      Math.round((significance = 10 ** (~~significance || 0)) * value) / significance;

    const renderFromURL = async (specifier, sourceType) => {
      let returned, fragment, render;

      const { repeats = 1, iterations = 1 } = options;
      const container = sourceCodeElement;
      const now = options.now || Date.now;

      const header = renderHeader({ rerender: () => render() });
      const { timing, status } = header;
      const time = async (name, executor, cycles = 1) => {
        let start, result, end, elapsed;
        start = now();
        result = await executor();
        end = now();
        elapsed = end - start;
        timing && timing(name, round(elapsed / cycles));
        return { name, executor, start, result, end, elapsed };
      }

      container.innerHTML = '';
      container.appendChild(header);
      const code = container.appendChild(document.createElement('slot'));

      try {

        await nextFrame(header.status('source', `${specifier}`), header.timing('source', true));
        const { result: { sourceText, response } } = await time('source', () => loadFromURL(specifier));
        sourceType = `${sourceType || response.headers.get('Content-Type') || options.sourceType}`.replace(/^(?:.*?\/)?(\w+).*$/, '$1').toLowerCase();
        sourceType in markup.modes || (sourceType = 'markup');
        const markupOptions = { sourceType };
        header.status('source', `${specifier}`);
        // header.status('source-type', `${sourceType}`);

        fragment = code;

        const sourceID = `«${specifier.replace(/^.*\//, '…/')} [${sourceText.length}] ${sourceType}»`;

        // const marker = mark => `<${specifier.replace(/^.*\//, '…/')} x ${sourceText.length}> ${mark}`;

        const iterate = iterations => {
          // for (let n = iterations; n--; [...markup.tokenize(sourceText, markupOptions)]);
          for (let n = iterations; n--;) {
            // markup.every(markup.tokenize(sourceText, markupOptions));
            for (const t of markup.tokenize(sourceText, markupOptions));
          }
          // for (let n = iterations; n--; Array.from(markup.tokenize(sourceText, markupOptions)));
          // for (let n = iterations, t; n-- && (t = markup.tokenize(sourceText, markupOptions));) while(!t.next().done);
          // console.timeEnd(mark);
        };

        const repeat = async repeats => {
          for (let n = repeats; n--; code.appendChild(await renderMarkup(sourceText, markupOptions)));
        }

        const timed = async (marker, ...args) => {
          console.time(marker = `${sourceID} - ${marker}`);
          await time(...args);
          console.timeEnd(marker);
        }

        render = async () => {
          await nextFrame(code.innerText = '');

          // header.stats({ name: 'render', status: `${sourceType}`, time: -1 });
          header.stats({ name: 'repeats', status: '', time: -1 });
          header.stats({ name: 'iterations', status: '', time: -1 });

          if (iterations > 0) {
            await nextFrame(header.stats({ name: 'iterations', status: `⁑${iterations}`, time: true }));
            await timeDelay(100);
            await timed(`${iterations} iterations`, 'iterations', async ƒ => void await iterate(iterations), iterations);
            await nextFrame(header.status('iterations', `⁑${iterations}`));
          }

          // if (repeats > 0) {
          //   await nextFrame(header.stats({ name: 'render', status: `${sourceType}`, time: true }));
          //   await timed('render', 'render', async ƒ => void
          //     code.appendChild(fragment = await renderMarkup(sourceText, markupOptions)));
          //   await nextFrame(header.status('render', `${sourceType}`));
          // }

          if (repeats > 0) {
            await nextFrame(header.stats({ name: 'repeats', status: `⁎${repeats}`, time: true }));
            await timed(`${repeats} repeats`, 'repeats', async ƒ => void await repeat(repeats), repeats);
            await nextFrame(header.status('repeats', `⁎${repeats}`));
          }

          return fragment;
        };

        await nextFrame();
        // markup.initialized || await markup.initialize();
        await markup.warmup(sourceText, markupOptions);
        await nextFrame(header.status('source-type', `${markupOptions.mode && markupOptions.mode.syntax || sourceType}`));
        // console.log(markupOptions);
        // await markup.warmup(sourceText.slice(0, 1000), markupOptions);
        fragment = await render();

        return returned = fragment;
      } finally {
        !returned && (container.innerText = 'Failed!');
      }
    }

    const renderFromHash = (hash = location.hash || '#') => {
      const [, specifier, type, repeats = defaults.repeats, iterations = defaults.iterations] = hashMatcher.exec(hash.trim());

      options.repeats = repeats >= 0 ? parseInt(repeats) : defaults.repeats;
      options.iterations = iterations >= 0 ? parseInt(iterations) : defaults.iterations;

      const example = /^\w[\w\-]*$/.test(specifier) && examples[specifier] || '';

      const source = (specifier && (example.url || example) || specifier);
      const sourceURL = (source && (options.source = source)) || options.source || (options.source = defaults.sourceURL);
      const sourceType = type || (example.type) || undefined;
      // console.log({sourceURL, sourceType},  {specifier, type, repeats, iterations}, {source});

      renderFromURL(sourceURL, sourceType);
    };

    window.addEventListener('hashchange', () => renderFromHash());

    requestAnimationFrame(() => renderFromHash(location.hash !== '#' && location.hash || `#${defaults.sourceURL}`));


    const examples = {
      "markup": "./lib/markup-parser.js",
      "markup-api": "./lib/markup.js",
      "markup-dom": "./lib/markup-dom.js",
      "markup-modes": "./lib/markup-modes.js",
      "leo-routes": "./benchmarks/assets/pholio-routes-profile.js",
      "punctuation": "./benchmarks/assets/punctuation.js",
      "babel": "./benchmarks/assets/babel.js",
      "acorn": "./benchmarks/assets/acorn.js",
      "acorn-esm": { url: "https://unpkg.com/acorn?module", type: 'esm' },
      "acorn-cjs": { url: "https://unpkg.com/acorn", type: 'cjs' },
      "acorn-loose": "https://cdnjs.cloudflare.com/ajax/libs/acorn/5.7.3/acorn_loose.es.js",
      "esprima": "https://cdnjs.cloudflare.com/ajax/libs/esprima/2.7.3/esprima.js",
      "babel-core": "https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.js",
      "babel-core-min": "https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.min.js",
      "popper": "https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/esm/popper.js",
      "xregexp": "https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.js",
      "xregexp-min": "https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.min.js",
    }

    sourceHeaderTemplate && (sourceHeaderTemplate.selectors = {
      'source-span': '#source',
      'source-time': '#source + time',
      'source-type-span': '#source-type',
      // 'type-time': '#type + time',
      // 'render-span': '#render',
      // 'render-time': '#render + time',
      'repeats-span': '#repeats',
      'repeats-time': '#repeats + time',
      'iterations-span': '#iterations',
      'iterations-time': '#iterations + time',
      'rerender-button': '#rerender[onclick]',
      'contrast-button': '#contrast[onclick]',
    });

  </script>
</body>

</html>
