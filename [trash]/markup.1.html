<!DOCTYPE html>
<html>

<head>
  <title>SMotaal's Markup</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="./markup.css">

  <template id=source-header>
    <header>
      <span name=source><span id=source></span><time></time></span>
      <span name=render><span id=render></span><time></time></span>
      <span name=repeats><span id=repeats></span><time></time></span>
      <span name=iterations><span id=iterations></span><time></time></span>
      <span name=controls><a id=rerender onclick="click()"><b>&#10227;</b></a></span>
    </header>
  </template>

  <style>
    body {
      margin: 0;
      display: flex;
      flex-flow: column;
      min-height: 100vh;
      width: 100vw;
      background-color: #999;
      font-size: 1rem;
    }

    #source-code {
      --markup-background: #F9F9F9;
      --markup-color: #666;
      --markup-shadow: #FFF;
      --markup-variables: red;
      --markup-keywords: olive;
      --markup-identifiers: darkslategrey;
      --markup-punctators: green;
      --markup-sequences: grey;
      --markup-operators: limegreen;
      --markup-combinator: steelblue;
      --markup-breakers: grey;
      --markup-quotes: teal;
      --markup-closures: orange;
      --markup-spans: coral;
      --markup-comments: #AAA;
      --markup-whitespace: #999;

      padding: 1ch;
      margin: 0;
      max-width: 100%;
      flex: 1;

      background-color: var(--markup-background, #444);
      color: var(--markup-color, #444);
      /* text-shadow: 0 0.875px 0 var(--markup-shadow, #FFF); */

      line-height: 1.5em;
      font-family: 'Iosevka', 'TypoPRO Iosevka Term', monospace;
      font-variant-ligatures: contextual;
      text-rendering: optimizeLegibility;
      white-space: pre-wrap;
      word-break: normal;
      line-break: strict;
    }

    #source-code > header {
      margin-bottom: 1ch;
      border-radius: 1ch;
      overflow: hidden;
      user-select: none;
      /* pointer-events: none; */

      background: #9993;
      color: #999;
      opacity: 0.8;

      font-family: system-ui -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-weight: 300;
      text-overflow: ellipsis;
      font-size: 0.875em;
      white-space: normal;
      line-break: normal;
      text-align: center;
      vertical-align: middle;
    }

    #source-code > header > * {
      display: inline-block;
      white-space: pre;
    }

    #source-code > header  input {
      user-select: text;
    }

    #source-code > header a[onclick]  {
      display: inline-grid;
      height: 1em;
      width: 1em;
      /* position: relative; */
      /* overflow: hidden; */
      margin: 0 0.5ch;
      padding: 0.25ch;

      border: 1px solid transparent;
      border-radius: 25%;

      text-align: center;
      /* vertical-align: middle; */
      line-height: 87.5%;
    }

    #source-code > header a[onclick]:hover  {
      background-color: #999;
      color: #FFF;
    }

  </style>

  <link-group id=samples>
    <!-- Source Code Samples -->
    <link-group id=markup>
      <!-- Markup -->
      <link id=markup rel=prefetch href="./lib/markup.js" />
      <link id=markup-dom rel=prefetch href="./lib/markup-dom.js" />
      <link id=markup-modes rel=prefetch href="./lib/markup-modes.js" />
    </link-group>
    <link-group id=examples>
      <!-- Examples -->
      <link id=leo-routes rel=prefetch href="./samples/pholio-routes-profile.js" />
      <link id=punctuation rel=prefetch href="./samples/punctuation.js" />
    </link-group>
    <link-group id=vendor>
      <!-- Third-party -->
      <link id=acorn rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/acorn/5.7.3/acorn_loose.es.js" />
      <link id=esprima rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/esprima/2.7.3/esprima.js" />
      <link id=babel-core rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.js" />
      <link id=babel-core-min rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.min.js" />
      <link id=popper rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/esm/popper.js" />
      <link id=xregexp rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.js" />
      <link id=xregexp-min rel=preconnect href="https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.min.js" />
    </link-group>
  </link-group>
</head>

<body>
  <pre id="source-code"></pre>
  <script type=module>
    import markup from './markup.js';

    const defaults = {
      repeats: 1,
      iterations: 1,
      sourceURL: './lib/markup.js',
      sourceType: undefined,
      elements: {
        container: 'pre#source-code',
        header: ''
      }
      element: 'pre#source-code',
      header: 'template#source-header',
    }

    const options = {
      ... defaults,
      // iterations: 500,
      // repeats: 0,
    };

    const sourceCodeElement = document.querySelector(options.element);
    const sourceHeaderTemplate = document.querySelector(options.header);

    sourceHeaderTemplate && sourceHeaderTemplate.elements = {
      'source-span': 'span#source',
      'source-time': 'span#source + time',
      'render-span': 'span#render',
      'render-time': 'span#render + time',
      'repeats-span': 'span#repeats',
      'repeats-time': 'span#repeats + time',
      'iterations-span': 'span#iterations',
      'iterations-time': 'span#iterations + time',
      'rerender-button': '[onclick]#rerender',
    };

    const loadFromURL = async (specifier) => {
      let fetched, response, result;
      const url = `${new URL(specifier, location)}`;
      const source = {specifier, url};
      try {
        source.response = await fetch(url);
        source.sourceText = await source.response.text();
        return result = source;
      } finally {
        result || console.warn('Failed to load source from "%s" — %o', specifier, source);
      }
    }

    const nextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));

    const spread = iterator => {
      const items = [];
      for (const item of iterator) items.push(item);
      return items;
    }

    const renderMarkup = (sourceText, markupOptions) =>
      markup.render(sourceText, (markupOptions.fragment || (markupOptions.fragment = document.createDocumentFragment()), markupOptions));

    const renderHeader = ({
      template = sourceHeaderTemplate,
      elements = template.elements,
      rerender = console.warn,
    }) => {
      const header = sourceHeaderTemplate.content.firstElementChild.cloneNode(true);

      if (elements) for (const [id, selector] in Object.entries(elements))  header[id] = selector && header.querySelector(selector) || undefined;

      if (header['rerender-button']) header['rerender-button'].click = rerender;

      return header;
    }

    const renderFromURL = async (specifier, sourceType) => {

      let returned;
      const {repeats = 1, iterations = 1} = options;

      await nextFrame();
      sourceCodeElement.innerText = `Loading "${specifier}"…`;

      try {
        const {sourceText, response} = await loadFromURL(specifier);

        (sourceType = sourceType || response.headers.get('Content-Type') || options.sourceType) && (sourceType = sourceType.split(';', 1)[0]);

        const markupOptions = {sourceType};

        let fragment;

        const render = async () => {
          await nextFrame();

          // sourceCodeElement.innerHTML = `<header><span>${
          //   specifier
          // }</span> [<span>${
          //   sourceType
          // }</span>] &times; <span>${repeats || 0}${
          //   `<span id=repeats></span>`
          // }</span> — <b>${
          //   `<span id=status>Rendering</span>`
          // }</b>${
          //   `<span id=render></span><span id=iterations></span>`
          // }${
          //   `<a id=rerender onclick=click()><b>&#10227;</b></a>`
          // }</header>`;
          // const rerender = sourceCodeElement.querySelector('#rerender');
          // const status = sourceCodeElement.querySelector('#status');
          // const renderStatus = sourceCodeElement.querySelector('#render');
          // const repeatStatus = sourceCodeElement.querySelector('#repeats');
          // const iterationStatus = sourceCodeElement.querySelector('#iterations');

          // rerender.click = render;

          const header = renderHeader({rerender: render});


          await nextFrame();

          let timing = {};
          let start = Date.now();
          const elapsed = (last = start) => Math.round(10 * ((start = Date.now()) - last))/10;

          fragment = sourceCodeElement;

          if (repeats > 0) {
            fragment = renderMarkup(sourceText, markupOptions);
            timing.render = elapsed();

            sourceCodeElement.appendChild(fragment);

            if (repeats > 1) {
              status.innerText = `Repeating`;
              await nextFrame();
              start = Date.now();
              for (let n = repeats; --n; sourceCodeElement.appendChild(renderMarkup(sourceText, markupOptions))); //  n % 10 || await nextFrame();
              timing.repeats = elapsed();
              repeatStatus && timing.repeats && (repeatStatus.innerText = ` ~${timing.repeats}ms`);
            }
          }

          if (iterations > 1) {
            status.innerText = `Iterating`;
            await nextFrame();
            start = Date.now();
            for (let n = iterations; n--; [... markup.tokenize(sourceText, markupOptions)]);
            timing.iterations = elapsed();
            iterationStatus && timing.iterations && (iterationStatus.innerText = ` (~${timing.iterations}ms / ${iterations})`);
          }
          status.innerText = 'Done';

          renderStatus && timing.render && (renderStatus.innerText = ` ~${timing.render}ms`);

          return fragment;
        };

        fragment = await render();

        return returned = fragment;
      } finally {
        !returned && (sourceCodeElement.innerText = 'Failed!');
      }
    }

    const renderFromHash = (hash = location.hash) => {
      const match = /#(.*?)(?:\!([a-z]+))?(?:\*(\d+))?(?:\*{2}(\d+))?$/.exec(hash);
      const [,specifier, type, repeats = defaults.repeats, iterations = defaults.iterations] = match || '';
      const sourceType = (type && `text/${type}`) || undefined;
      options.repeats = repeats >= 0 ? parseInt(repeats) : defaults.repeats;
      options.iterations = iterations >= 1 ? parseInt(iterations) : defaults.iterations;
      const link = /^\w[\w\-]*$/.test(specifier) && document.querySelector(`link#${specifier}`);
      const source = link && link.href || specifier;
      console.log(match, {specifier, link, source, type, repeats, iterations});
      specifier && renderFromURL(source, sourceType);
    };

    window.addEventListener('hashchange', () => renderFromHash());

    requestAnimationFrame(() => renderFromHash(location.hash !== '#' && location.hash || `#${defaults.sourceURL}`));

</script>
  <script src>
    {
      let worker;
      try {
        worker = new Worker(`data:text/javascript;base64,${btoa('console.log(import.meta)')}`, { type: 'module' })
        console.log(worker);
      } catch (exception) {
        console.warn(exception);
        worker && setTimeout(() => worker.terminate(), 5000);
      }
    }
  </script>
</body>

</html>
