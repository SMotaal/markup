<!DOCTYPE html>
<html>

<head>
  <title>SMotaal's Markup</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0, viewport-fit=cover">
  <link rel="stylesheet" href="./styles.css" />

  <template id="source-header">
    <header>
      <div id="summary">
        <span title="SourceTextURL">#<span id="source"></span><time></time></span>
      </div>
      <div id="details">
        <span title="render"><span id="render"></span><time></time></span>
        <span title="repeats"><span id="repeats"></span><time></time></span>
        <span title="iterations"><span id="iterations"></span><time></time></span>
      </div>
      <div id="controls">
        <span>
          <a id="rerender" title="Rerender" onclick="click()"><i icon>&#x27f3;</i></a>
          <a id="contrast" title="Dark/Light Mode" onclick="click()"><i icon>&#x263D;</i></a>
        </span>
      </div>
    </header>
  </template>
  <template>
    <custom-element custom-attribute=true namespace:attribute=false></custom-element>
  </template>

  <script src="service-worker-client.js">
    navigator.serviceWorker && (async serviceWorker => {
      const registration = await serviceWorker.register('./service-worker.js', { scope: './caches/' });

      const worker =
        (registration.installing && (await registration.installing)) ||
        (registration.waiting && (await registration.waiting)) ||
        (registration.active);

      worker.addEventListener('statechange', console.info);

      // Unregister Redundant
      const registrations = await serviceWorker.getRegistrations();

      console.log({ registration, registrations, worker });

      // for (const registration of registrations) {
      //   console.log(registration);
      // }
    })(navigator.serviceWorker);
  </script>
</head>

<body>
  <!-- <script src="./scripts/rollup-frame.js"></script> -->
  <script>
    new Worker('./rollup-worker.js');
    // new Worker('./caches/worker.js');
  </script>
  <pre id="source-code" class="markup-container" hidden>
    <script>
      {
        const element = document.currentScript.parentElement;

        // TODO: Add support for @media (prefers-dark-mode) when it lands
        const prefersDarkInterface = matchMedia('prefers-dark-interface');

        (
          matchMedia('prefers-dark-interface').matches &&
          !element.classList.add('prefers-dark-mode') ||
          localStorage.darkMode
        ) && element.classList.add('dark-mode');

        element.hidden = false;

        // navigator.serviceWorker && (async () => (await navigator.serviceWorker.getRegistrations()).forEach(registration => registration.unregister))();
      }
    </script>
  </pre>

  <script type="module">
    import markup from './markup.js';

    const defaults = {
      repeats: 1,
      iterations: 0,
      sourceURL: './lib/markup.js',
      sourceType: undefined,
      element: 'pre#source-code',
      headerTemplate: 'template#source-header',
    }
    const hashMatcher = /#(.*?)(?:\!([a-z]+)|\!.*?)?(?:\*(?!\*)(\d+))?(?:\*{2}(\d+))?$/;
    const options = Object.create(defaults);
    const sourceCodeElement = document.querySelector(options.element);
    const sourceHeaderTemplate = document.querySelector(options.headerTemplate);

    const loadFromURL = async (specifier) => {
      let fetched, response, result;
      const url = `${new URL(specifier, location)}`;
      const source = { specifier, url };
      try {
        source.response = await fetch(url);
        source.sourceText = await source.response.text();
        return result = source;
      } finally {
        result || console.warn('Failed to load source from "%s" — %o', specifier, source);
      }
    }

    const nextFrame = () => new Promise(ƒ => requestAnimationFrame(ƒ));

    const renderMarkup = (sourceText, markupOptions) => (
      markupOptions.fragment || (markupOptions.fragment = document.createDocumentFragment()),
      markup.render(sourceText, markupOptions)
    );

    const renderHeader = ({
      template = sourceHeaderTemplate,
      selectors = template.selectors,
      rerender = console.warn,
    }) => {
      /** @type {HTMLElement} */
      const header = template.content.firstElementChild.cloneNode(true);

      header.elements = {};

      if (selectors) {
        for (const [id, selector] of Object.entries(selectors)) {
          header.elements[id] = selector && header.querySelector(selector) || undefined;
        }
      }

      header.elements['rerender-button'] && (header.elements['rerender-button'].click = rerender);
      header.elements['contrast-button'] && (header.elements['contrast-button'].click = async () => {
        const parent = header.parentElement;
        if (parent) {
          parent.classList.toggle('dark-mode')
            ? (localStorage.darkMode = true)
            : (delete localStorage.darkMode);
        }
      });


      header.status = (name, value) => {
        header.status[name] === (header.status[name] = value);
        const element = header.elements[`${name}-span`];
        const text = `${value || ''}`;
        element ? element.innerText = text : text && console.info('[%s] %o', name, value);
      }

      header.timing = (name, value) => {
        header.timing[name] === (header.timing[name] = value);
        const status = header.status[name] || 'done';
        const element = header.elements[`${name}-time`];
        const text = value === true ? '…' : value >= 0 ? `${value} ms` : '';
        element ? element.innerText = text : text && console.info('[%s] %o — %o', name, status, value);
      }

      header.stats = ({ name, status, time }) => {
        !name || (
          status === undefined || header.status(name, status),
          time === undefined || header.timing(name, time)
        );
      }

      header.reset = () => {
        for (const [id, element] of Object.entries(header.elements)) {
          /-time|-span/.test(id) && (element.innerText = '');
        }
      }

      return header;
    }

    const round = (value, significance = 1) =>
      Math.round((significance = 10 ** (~~significance || 0)) * value) / significance;

    const renderFromURL = async (specifier, sourceType) => {
      let returned, fragment, render;

      const { repeats = 1, iterations = 0 } = options;
      const container = sourceCodeElement;
      const now = options.now || Date.now;

      const header = renderHeader({ rerender: () => render() });
      const { timing, status } = header;
      const time = async (name, executor, cycles = 1) => {
        let start, result, end, elapsed;
        start = now();
        result = await executor();
        end = now();
        elapsed = end - start;
        timing && timing(name, round(elapsed / cycles));
        return { name, executor, start, result, end, elapsed };
      }

      container.innerHTML = '';
      container.appendChild(header);
      const code = container.appendChild(document.createElement('slot'));

      try {

        await nextFrame(header.status('source', `${specifier}`), header.timing('source', true));
        const { result: { sourceText, response } } = await time('source', () => loadFromURL(specifier));
        sourceType = `${sourceType || response.headers.get('Content-Type') || options.sourceType}`.replace(/^(?:.*?\/)?(\w+).*$/, '$1').toLowerCase();
        sourceType in markup.modes || (sourceType = 'markup');
        const markupOptions = { sourceType };
        header.status('source', `${specifier}`);

        fragment = code;

        const iterate = iterations => {
          for (let n = iterations; n--; [...markup.tokenize(sourceText, markupOptions)]);
        };

        const repeat = repeats => {
          for (let n = repeats; n--; code.appendChild(renderMarkup(sourceText, markupOptions)));
        }

        render = async () => {
          await nextFrame(code.innerText = '');

          header.stats({ name: 'render', status: '', time: -1 });
          header.stats({ name: 'repeats', status: '', time: -1 });
          header.stats({ name: 'iterations', status: '', time: -1 });

          if (repeats > 0) {
            await nextFrame(header.stats({ name: 'render', status: `${sourceType}`, time: true }));
            time('render', ƒ => {
              fragment = renderMarkup(sourceText, markupOptions);
              code.appendChild(fragment);
            });
            header.status('render', `${sourceType}`);
          }

          if (repeats > 1) {
            await nextFrame(header.stats({ name: 'repeats', status: `⁎${repeats}`, time: true }))
            time('repeats', async ƒ => repeat(repeats - 1), repeats - 1);
            header.status('repeats', `⁎${repeats}`);
          }

          if (iterations > 0) {
            await nextFrame(header.stats({ name: 'iterations', status: `⁑${iterations}`, time: true }))

            time('iterations', async ƒ => iterate(iterations), iterations);

            header.status('iterations', `⁑${iterations}`);
          }

          return fragment;
        };

        await nextFrame();
        fragment = await render();

        return returned = fragment;
      } finally {
        !returned && (container.innerText = 'Failed!');
      }
    }

    const renderFromHash = (hash = location.hash || '#') => {
      const [, specifier, type, repeats = defaults.repeats, iterations = defaults.iterations] = hashMatcher.exec(hash);

      options.repeats = repeats >= 0 ? parseInt(repeats) : defaults.repeats;
      options.iterations = iterations >= 0 ? parseInt(iterations) : defaults.iterations;

      const source = (specifier && (/^\w[\w\-]*$/.test(specifier) && examples[specifier]) || specifier);

      const sourceURL = (source && (options.source = source)) || options.source || (options.source = defaults.sourceURL);
      const sourceType = type || undefined;

      // console.log({sourceURL, sourceType},  {specifier, type, repeats, iterations}, {source});

      renderFromURL(sourceURL, sourceType);
    };

    window.addEventListener('hashchange', () => renderFromHash());

    requestAnimationFrame(() => renderFromHash(location.hash !== '#' && location.hash || `#${defaults.sourceURL}`));


    const examples = {
      "markup": "./lib/markup.js",
      "markup-dom": "./lib/markup-dom.js",
      "markup-modes": "./lib/markup-modes.js",
      "leo-routes": "./benchmarks/assets/pholio-routes-profile.js",
      "punctuation": "./benchmarks/assets/punctuation.js",
      "babel": "./benchmarks/assets/babel.js",
      "acorn": "https://cdnjs.cloudflare.com/ajax/libs/acorn/5.7.3/acorn_loose.es.js",
      "esprima": "https://cdnjs.cloudflare.com/ajax/libs/esprima/2.7.3/esprima.js",
      "babel-core": "https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.js",
      "babel-core-min": "https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.min.js",
      "popper": "https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/esm/popper.js",
      "xregexp": "https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.js",
      "xregexp-min": "https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.min.js",
    }

    sourceHeaderTemplate && (sourceHeaderTemplate.selectors = {
      'source-span': '#source',
      'source-time': '#source + time',
      'render-span': '#render',
      'render-time': '#render + time',
      'repeats-span': '#repeats',
      'repeats-time': '#repeats + time',
      'iterations-span': '#iterations',
      'iterations-time': '#iterations + time',
      'rerender-button': '#rerender[onclick]',
      'contrast-button': '#contrast[onclick]',
    });

  </script>
</body>

</html>
