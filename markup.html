<!DOCTYPE html>
<html>

<head>
  <title>SMotaal's Markup</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="./markup.css">
  <style>
    body {
      margin: 0;
      display: flex;
      flex-flow: column;
      min-height: 100vh;
      width: 100vw;
      background-color: #999;
    }

    #source-code {
      --markup-background: #F9F9F9;
      --markup-color: #666;
      --markup-shadow: #FFF;
      --markup-variables: red;
      --markup-keywords: olive;
      --markup-identifiers: darkslategrey;
      --markup-punctators: green;
      --markup-sequences: grey;
      --markup-operators: limegreen;
      --markup-combinator: steelblue;
      --markup-breakers: grey;
      --markup-quotes: teal;
      --markup-closures: orange;
      --markup-spans: coral;
      --markup-comments: #AAA;
      --markup-whitespace: #999;

      background-color: var(--markup-background, #444);
      line-height: 1.375em;
      text-shadow: 0 1px 0 var(--markup-shadow, #FFF);
      text-rendering: optimizeLegibility;
      color: var(--markup-color, #444);
      font-family: 'Iosevka', 'TypoPRO Iosevka Term', monospace;
      font-variant-ligatures: contextual;
      white-space: pre-wrap;
      position: relative;
      padding: 1ch;
      margin: 0;
      max-width: 100%;
      flex: 1;
    }

    #source-code > header {
      /* font-family: system-ui; */
      font-weight: 300;
      white-space: pre;
      background: #9993;
      color: #999;
      margin-bottom: 1ch;
      opacity: 0.8;
      border-radius: 1ch;
    }

  </style>
</head>

<body>
  <pre id="source-code"></pre>
  <script type=module>
    import {markup} from './markup.js';

    const defaults = {
      repeats: 0,
      iterations: 0,
      sourceURL: './lib/markup.js',
      sourceType: undefined,
      element: 'pre#source-code',
    }

    const options = {
      ... defaults,
      // iterations: 500,
      // repeats: 0,
    };

    const sourceCodeElement = document.querySelector(options.element);

    const loadFromURL = async (specifier) => {
      let fetched, response, result;
      const url = `${new URL(specifier, location)}`;
      const source = {specifier, url};
      try {
        source.response = await fetch(url);
        source.sourceText = await source.response.text();
        return result = source;
      } finally {
        result || console.warn('Failed to load source from "%s" — %o', specifier, source);
      }
    }

    const nextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));
    // const nextStep = () => new Promise(resolve => setTimeout(resolve));

    const spread = iterator => {
      const items = [];
      for (const item of iterator) items.push(item);
      return items;
    }

    // let defaultSoutceType = location.search && location.search.slice(1);

    const renderMarkup = (sourceText, markupOptions) => {
      const target = document.createDocumentFragment();
      const nodes = markup(`${sourceText}\n`, markupOptions);
      // sourceText ? [...  markup(sourceText, markupOptions)] : [];
      if (target.append) {
        while (nodes.length > 500) target.append(... nodes.splice(0, 500));
        nodes.length && target.append(... nodes);
      } else if (target.appendChild) {
        for (const node of nodes) target.appendChild(node);
      }
      return target;
    }

    const renderFromURL = async (specifier, sourceType) => {

      let returned;
      const {repeats = 1, iterations = 1} = options;

      await nextFrame();
      sourceCodeElement.innerText = `Loading "${specifier}"…`;

      try {
        const {sourceText, response} = await loadFromURL(specifier);

        (sourceType = sourceType || response.headers.get('Content-Type') || options.sourceType) && (sourceType = sourceType.split(';', 1)[0]);

        const markupOptions = {sourceType};

        await nextFrame();

        sourceCodeElement.innerHTML = `<header><center><label>source=<q><em>${specifier}</em></q></label>  <label>type=<q><em>${sourceType}</em></q></label>  <label>repeats=<em>${(repeats || 0) + 1}</em></label><span id=repeats></span>  <label>iterations=<em>${(iterations || 0) + 1}</em></label><span id=iterations></span> — <b><span id=status> Rendering</span></b><span id=render></span></center></header>`;

        const status = sourceCodeElement.querySelector('#status');
        const renderStatus = sourceCodeElement.querySelector('#render');
        const repeatStatus = sourceCodeElement.querySelector('#repeats');
        const iterationStatus = sourceCodeElement.querySelector('#iterations');

        await nextFrame();

        let timing = {};
        let start = Date.now();
        const elapsed = (last = start) => Math.round(10 * ((start = Date.now()) - last))/10;

        const fragment = renderMarkup(sourceText, markupOptions);
        timing.render = elapsed();

        sourceCodeElement.appendChild(fragment);

        if (repeats > 0) {
          status.innerText = `Repeating`;
          await nextFrame();
          start = Date.now();
          // const hr = document.createElement('hr');
          // sourceCodeElement.appendChild(hr.cloneNode())
          for (let n = repeats; n--; sourceCodeElement.appendChild(renderMarkup(sourceText, markupOptions))); //  n % 10 || await nextFrame();
          timing.repeats = elapsed();
          repeatStatus && timing.repeats && (repeatStatus.innerText = ` ~${timing.repeats}ms`);
        }

        if (iterations > 0) {
          status.innerText = `Iterating`;
          await nextFrame();
          start = Date.now();
          // for (let n = iterations; n--; [...  markup(sourceText, markupOptions)]);
          for (let n = iterations; n--; markup(sourceText, markupOptions));
          timing.iterations = elapsed();
          iterationStatus && timing.iterations && (iterationStatus.innerText = ` ~${timing.iterations}ms`);
        }
        // let times = `~ ${timing.rendered} ms${timing.repeats ? ` * ${repeats + 1} ~= ${timing.repeats} ms` : ''}${timing.iterations ? ` ** ${iterations + 1} ~= ${timing.iterations} ms` : ''}`;
        status.innerText = 'Done';

        renderStatus && timing.render && (renderStatus.innerText = ` ~${timing.render}ms`);

        return returned = fragment;
      } finally {
        !returned && (sourceCodeElement.innerText = 'Failed!');
      }
    }

    const renderFromHash = (hash = location.hash) => {
      // const match = /#(.*?)(?=\!(\d+)|$)/.exec(hash);
      const match = /#(.*?)(?:\!([a-z]+))?(?:\*(\d+))?(?:\*{2}(\d+))?$/.exec(hash);
      const [,specifier, type, repeats = defaults.repeats, iterations = defaults.iterations] = match || '';
      const sourceType = (type && `text/${type}`) || undefined;
      options.repeats = repeats >= 1 ? parseInt(repeats) - 1 : defaults.repeats;
      options.iterations = iterations >= 1 ? parseInt(iterations) - 1 : defaults.iterations;
      console.log(match, {specifier, type, repeats, iterations});
      // const specifier = hash && decodeURIComponent(hash.slice(1));
      specifier && renderFromURL(specifier, sourceType);
    };

    window.addEventListener('hashchange', () => renderFromHash());

    requestAnimationFrame(() => renderFromHash(location.hash !== '#' && location.hash || `#${defaults.sourceURL}`));



    // const renderMarkup = (target, sourceText, markupOptions) => {
    //   const nodes = sourceText ? [...  markup(sourceText, markupOptions)] : [];
    //   while (nodes.length > 500) target.append(... nodes.splice(0, 500));
    //   nodes.length && target.append(... nodes);
    //   return nodes;
    // }

  </script>
  <script>
    {
      let worker;
      try {
        worker = new Worker(`data:text/javascript;base64,${btoa('console.log(import.meta)')}`, { type: 'module' })
        console.log(worker);
      } catch (exception) {
        console.warn(exception);
        worker && setTimeout(() => worker.terminate(), 5000);
      }
    }
  </script>
</body>

</html>
