<!DOCTYPE html>
<html>

<head>
  <title>SMotaal's Markup</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="./styles.css" />

  <template id=source-header>
    <header>
      <span title=source>#<span id=source></span><time></time></span>
      <span title=render><span id=render></span><time></time></span>
      <span title=repeats><span id=repeats></span><time></time></span>
      <span title=iterations><span id=iterations></span><time></time></span>
      <span>
        <a id=rerender title="Rerender" onclick="click()"><i icon>&#x27f3</i></a>
        <a id=contrast title="Dark/Light Mode" onclick="click()"><i icon>&#x263C;</i></a>
      </span>
    </header>
  </template>

  <link-group id=samples>
    <!-- Source Code Samples -->
    <link-group id=markup>
      <!-- Markup -->
      <link id=markup rel=prefetch href="./lib/markup.js" />
      <link id=markup-dom rel=prefetch href="./lib/markup-dom.js" />
      <link id=markup-modes rel=prefetch href="./lib/markup-modes.js" />
    </link-group>
    <link-group id=examples>
      <!-- Examples -->
      <link id=leo-routes rel=prefetch href="./samples/pholio-routes-profile.js" />
      <link id=punctuation rel=prefetch href="./samples/punctuation.js" />
    </link-group>
    <link-group id=vendor>
      <!-- Third-party -->
      <link id=acorn rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/acorn/5.7.3/acorn_loose.es.js" />
      <link id=esprima rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/esprima/2.7.3/esprima.js" />
      <link id=babel rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.js" />
      <link id=babel-min rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/6.1.19/browser.min.js" />
      <link id=popper rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/esm/popper.js" />
      <link id=xregexp rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.js" />
      <link id=xregexp-min rel=prefetch href="https://cdnjs.cloudflare.com/ajax/libs/xregexp/3.2.0/xregexp-all.min.js" />
    </link-group>
  </link-group>
</head>

<body>
  <pre id="source-code" hidden>
    <script>
      {
        const element = document.currentScript.parentElement;
        localStorage.darkMode && element.classList.add('dark-mode');
        element.hidden = false;
      }
    </script>
  </pre>

  <script type=module>
    import markup from './markup.js';

    const defaults = {
      repeats: 1,
      iterations: 1,
      sourceURL: './lib/markup.js',
      sourceType: undefined,
      element: 'pre#source-code',
      headerTemplate: 'template#source-header',
    }

    const options = {
      ... defaults,
      // iterations: 500,
      // repeats: 0,
    };

    const sourceCodeElement = document.querySelector(options.element);
    const sourceHeaderTemplate = document.querySelector(options.headerTemplate);

    sourceHeaderTemplate && (sourceHeaderTemplate.selectors = {
      'source-span': '#source',
      'source-time': '#source + time',
      'render-span': '#render',
      'render-time': '#render + time',
      'repeats-span': '#repeats',
      'repeats-time': '#repeats + time',
      'iterations-span': '#iterations',
      'iterations-time': '#iterations + time',
      'rerender-button': '#rerender[onclick]',
      'contrast-button': '#contrast[onclick]',
    });

    const loadFromURL = async (specifier) => {
      let fetched, response, result;
      const url = `${new URL(specifier, location)}`;
      const source = {specifier, url};
      try {
        source.response = await fetch(url);
        source.sourceText = await source.response.text();
        return result = source;
      } finally {
        result || console.warn('Failed to load source from "%s" — %o', specifier, source);
      }
    }

    const nextFrame = () => new Promise(ƒ => requestAnimationFrame(ƒ));

    const renderMarkup = (sourceText, markupOptions) => (
      markupOptions.fragment || (markupOptions.fragment = document.createDocumentFragment()),
      markup.render(sourceText, markupOptions)
    );

    const renderHeader = ({
      template = sourceHeaderTemplate,
      selectors = template.selectors,
      rerender = console.warn,
    }) => {
      /** @type {HTMLElement} */
      const header = template.content.firstElementChild.cloneNode(true);

      header.elements = {};

      if (selectors) {
        for (const [id, selector] of Object.entries(selectors)) {
          header.elements[id] = selector && header.querySelector(selector) || undefined;
        }
      }

      header.elements['rerender-button'] && (header.elements['rerender-button'].click = rerender);
      header.elements['contrast-button'] && (header.elements['contrast-button'].click = async () => {
        const parent = header.parentElement;
        if (parent) {
          // if (!parent.style.transition) {
          //   parent.style.transition = 'background 375ms ease-in-out';
          //   await nextFrame();
          // }
          parent.classList.toggle('dark-mode')
            ? (localStorage.darkMode = true)
            : (delete localStorage.darkMode);
          // setTimeout(() => parent.style.transition = undefined, 500);
        }
      });


      header.status = (name, value) => {
        header.status[name] === (header.status[name] = value);
        const element = header.elements[`${name}-span`];
        const text = `${value || ''}`;
        element ? element.innerText = text : text && console.info('[%s] %o', name, value);
      }
      header.timing = (name, value) => {
        header.timing[name] === (header.timing[name] = value);
        const status = header.status[name] || 'done';
        const element = header.elements[`${name}-time`];
        const text = value === true ? '…' : value >= 0 ? `${value} ms` : '';
        element ? element.innerText = text : text && console.info('[%s] %o — %o', name, status, value);
      }

      header.reset = () => {
        for (const [id, element] of Object.entries(header.elements)) {
          /-time|-span/.test(id) && (element.innerText = '');
        }
      }

      return header;
    }

    const round = (value, significance = 1) =>
      Math.round((significance = 10 ** (~~significance || 0)) * value) / significance;

    const renderFromURL = async (specifier, sourceType) => {
      let returned, fragment, render;

      const {repeats = 1, iterations = 1} = options;
      const container = sourceCodeElement;
      const now = options.now || Date.now;

      const header = renderHeader({rerender: () => render()});
      const {timing, status} = header;
      const time = async (name, executor) => {
        let start, result, end, elapsed;
        start = now();
        result = await executor();
        end = now();
        elapsed = end - start;
        timing && timing(name, round(elapsed));
        return {name, executor, start, result, end, elapsed};
      }

      container.innerHTML = '';
      container.appendChild(header);
      const code = container.appendChild(document.createElement('slot'));

      try {

        await nextFrame(header.status('source', `${specifier}`), header.timing('source', true));
        const { result: {sourceText, response} } = await time('source', () => loadFromURL(specifier));
        sourceType = `${sourceType || response.headers.get('Content-Type') || options.sourceType}`.replace(/^(?:.*?\/)?(\w+).*$/, '$1').toLowerCase();
        sourceType in markup.modes || (sourceType = 'markup');
        const markupOptions = {sourceType};
        header.status('source', `${specifier}`);

        fragment = code;

        render = async () => {
          code.innerText = '';
          await nextFrame();

          header.timing('render', true);
          repeats > 1 && header.timing('repeats', true);
          iterations > 1 && header.timing('iterations', true);

          if (repeats > 0) {
            await nextFrame(header.status('render', `${sourceType}`), header.timing('render', true));
            time('render', ƒ => {
              fragment = renderMarkup(sourceText, markupOptions);
              code.appendChild(fragment);
            });
            header.status('render', `${sourceType}`);

          }

          if (repeats > 1) {
            await nextFrame(header.status('repeats', `* ${repeats}…`), header.timing('repeats', true));
            time('repeats', async ƒ => {
              for (let n = repeats; --n; code.appendChild(renderMarkup(sourceText, markupOptions)));
              //  n % 10 || await nextFrame();
            });
            header.status('repeats', `×${repeats}`);
          }

          if (iterations > 1) {
            await nextFrame(header.status('iterations', `* ${iterations}…`), header.timing('iterations', true));
            time('iterations', async ƒ => {
              for (let n = iterations; n--; [... markup.tokenize(sourceText, markupOptions)]);
            });
            header.status('iterations', `×${iterations}`);
          }

          return fragment;
        };

        fragment = await render();

        return returned = fragment;
      } finally {
        !returned && (container.innerText = 'Failed!');
      }
    }

    const renderFromHash = (hash = location.hash) => {
      const match = /#(.*?)(?:\!([a-z]+))?(?:\*(\d+))?(?:\*{2}(\d+))?$/.exec(hash);
      const [,specifier, type, repeats = defaults.repeats, iterations = defaults.iterations] = match || '';
      const sourceType = type || undefined;
      options.repeats = repeats >= 0 ? parseInt(repeats) : defaults.repeats;
      options.iterations = iterations >= 1 ? parseInt(iterations) : defaults.iterations;
      const link = /^\w[\w\-]*$/.test(specifier) && document.querySelector(`link#${specifier}`);
      const source = link && link.href || specifier || options.source;
      source && (options.source = source);
      // console.log(match, {specifier, link, source, type, repeats, iterations});
      specifier && renderFromURL(source, sourceType);
    };

    window.addEventListener('hashchange', () => renderFromHash());

    requestAnimationFrame(() => renderFromHash(location.hash !== '#' && location.hash || `#${defaults.sourceURL}`));

</script>
</body>

</html>
