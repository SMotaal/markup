{"version":3,"file":"tokenizer.mjs","sources":["../../packages/@smotaal/tokenizer/lib/grouping.mjs","../../packages/@smotaal/tokenizer/lib/tokenizer.mjs","../../packages/@smotaal/tokenizer/lib/parser.mjs"],"sourcesContent":["const {defineProperty} = Object;\n\nconst setProperty = (target, property, value, enumerable = true, configurable = true) =>\n  defineProperty(target, property, {value, enumerable, configurable}) && value;\n\n/** @typedef {import('./tokenizer.mjs').Grouping} Grouping */\n/** @typedef {import('./tokenizer.mjs').Tokenizer} Tokenizer */\n/** @typedef {import('./tokenizer.mjs').Token} Token */\n/** @typedef {import('./tokenizer.mjs')['Tokenizer']} TokenizerClass */\n/** @typedef {{[name: string]: Grouping}} Groupers */\n/** @typedef {(TokenizerClass)['createGrouper']} createGrouper */\n\nexport class Grouping {\n  /**\n   * @param {{syntax: string, groupers: Groupers, createGrouper: createGrouper}} options\n   */\n  constructor({syntax, groupers, createGrouper, contextualizer}) {\n    this.groupers = groupers;\n    this.groupings = [];\n    this.hints = new Set();\n    this.syntax = syntax;\n    this.goal = syntax;\n    this.hint = syntax;\n    this.contextualizer = contextualizer;\n    this.context = syntax;\n    this.create = createGrouper || Object;\n  }\n\n  /**\n   * @param {Token} next\n   * @param {Token} parent\n   * @param state\n   * @param context\n   */\n  close(next, state, context) {\n    let after, grouper, parent;\n    const {groupings, hints, syntax} = this;\n\n    const closed = groupings.pop();\n    grouper = closed;\n    groupings.includes(grouper) || hints.delete(grouper.hinter);\n\n    (closed.punctuator === 'opener' && (next.punctuator = 'closer')) ||\n      (closed.punctuator && (next.punctuator = closed.punctuator));\n\n    after = grouper.close && grouper.close(next, state, context);\n\n    const previousGrouper = (grouper = groupings[groupings.length - 1]);\n\n    this.goal = (previousGrouper && previousGrouper.goal) || syntax;\n    this.grouper = previousGrouper;\n\n    parent = (next.parent && next.parent.parent) || undefined;\n\n    return {after, grouper, closed, parent};\n  }\n\n  open(next, context) {\n    let opened, parent, grouper;\n\n    const {groupers, groupings, hints, hint, syntax} = this;\n    let {punctuator, text} = next;\n    const hinter = punctuator ? `${syntax}-${punctuator}` : hint;\n    const group = `${hinter},${text}`;\n\n    grouper = groupers[group];\n\n    const {\n      mode: {matchers, comments, spans, closures},\n    } = context;\n\n    if (context.spans && punctuator === 'span') {\n      const span = context.spans.get(text);\n      punctuator = next.punctuator = 'span';\n      opened =\n        grouper ||\n        this.create({\n          syntax,\n          goal: syntax,\n          span,\n          matcher: span.matcher || (matchers && matchers.span) || undefined,\n          spans: (spans && spans[text]) || undefined,\n          hinter,\n          punctuator,\n        });\n    } else if (context.punctuator !== 'quote') {\n      if (punctuator === 'quote') {\n        opened =\n          grouper ||\n          this.create({\n            syntax,\n            goal: punctuator,\n            quote: text,\n            matcher: (matchers && matchers.quote) || undefined,\n            spans: (spans && spans[text]) || undefined,\n            hinter,\n            punctuator,\n          });\n      } else if (punctuator === 'comment') {\n        const comment = comments.get(text);\n        opened =\n          grouper ||\n          this.create({\n            syntax,\n            goal: punctuator,\n            comment,\n            matcher: comment.matcher || (matchers && matchers.comment) || undefined,\n            hinter,\n            punctuator,\n          });\n      } else if (punctuator === 'closure') {\n        const closure = (grouper && grouper.closure) || closures.get(text);\n        punctuator = next.punctuator = 'opener';\n        closure &&\n          (opened =\n            grouper ||\n            this.create({\n              syntax,\n              goal: syntax,\n              closure,\n              matcher: closure.matcher || (matchers && matchers.closure) || undefined,\n              hinter,\n              punctuator,\n            }));\n      }\n    }\n\n    if (opened) {\n      groupers[group] || (groupers[group] = grouper = opened);\n      groupings.push(grouper), hints.add(hinter);\n      this.goal = (grouper && grouper.goal) || syntax;\n      parent = next;\n    }\n\n    return {grouper, opened, parent, punctuator};\n  }\n}\n","import {Grouping} from './grouping.mjs';\n\n/** Tokenizer for a single mode (language) */\nexport class Tokenizer {\n  constructor(mode, defaults) {\n    this.mode = mode;\n    this.defaults = defaults || this.constructor.defaults || undefined;\n  }\n\n  /** Token generator from source using tokenizer.mode (or defaults.mode) */\n  *tokenize(source, state = {}) {\n    let done;\n\n    // TODO: Consider supporting Symbol.species\n    const Species = this.constructor;\n\n    // Local context\n    const contextualizer = this.contextualizer || (this.contextualizer = Species.contextualizer(this));\n    let context = contextualizer.next().value;\n\n    const {mode, syntax, createGrouper = Species.createGrouper || Object} = context;\n\n    // Local grouping\n    const groupers = mode.groupers || (mode.groupers = {});\n    const grouping =\n      state.grouping ||\n      (state.grouping = new Grouping({\n        syntax: syntax || mode.syntax,\n        groupers,\n        createGrouper,\n        contextualizer,\n      }));\n\n    // Local matching\n    let {match, index = 0} = state;\n\n    // Local tokens\n    let previous, last, parent;\n    const top = {type: 'top', text: '', offset: index};\n\n    let lastContext = context;\n\n    state.source = source;\n\n    const tokenize = state.tokenize || (text => [{text}]);\n\n    while (true) {\n      const {\n        mode: {syntax, matchers, comments, spans, closures},\n        punctuator: $$punctuator,\n        closer: $$closer,\n        spans: $$spans,\n        matcher: $$matcher,\n        token,\n        forming = true,\n      } = context;\n\n      // Current contextual hint (syntax or hint)\n      const hint = grouping.hint;\n\n      while (lastContext === (lastContext = context)) {\n        let next;\n\n        state.last = last;\n\n        const lastIndex = state.index || 0;\n\n        $$matcher.lastIndex = lastIndex;\n        match = state.match = $$matcher.exec(source);\n        done = index === (index = state.index = $$matcher.lastIndex) || !match;\n\n        if (done) return;\n\n        // Current contextual match\n        const {0: text, 1: whitespace, 2: sequence, index: offset} = match;\n\n        // Current quasi-contextual fragment\n        const pre = source.slice(lastIndex, offset);\n        pre &&\n          ((next = token({\n            type: 'pre',\n            text: pre,\n            offset: lastIndex,\n            previous,\n            parent,\n            hint,\n            last,\n            source,\n          })),\n          yield (previous = next));\n\n        // Current contextual fragment\n        const type = (whitespace && 'whitespace') || (sequence && 'sequence') || 'text';\n        next = token({type, text, offset, previous, parent, hint, last, source});\n\n        // Current contextual punctuator (from sequence)\n        const closing =\n          $$closer &&\n          ($$closer.test ? $$closer.test(text) : $$closer === text || (whitespace && whitespace.includes($$closer)));\n\n        let after;\n        let punctuator = next.punctuator;\n\n        if (punctuator || closing) {\n          let closed, opened, grouper;\n\n          if (closing) {\n            ({after, closed, parent = top, grouper} = grouping.close(next, state, context));\n          } else if ($$punctuator !== 'comment') {\n            ({grouper, opened, parent = top, punctuator} = grouping.open(next, context));\n          }\n\n          state.context = grouping.context = grouping.goal || syntax;\n\n          if (opened || closed) {\n            next.type = 'punctuator';\n            context = contextualizer.next((state.grouper = grouper || undefined)).value;\n            grouping.hint = `${[...grouping.hints].join(' ')} ${grouping.context ? `in-${grouping.context}` : ''}`;\n            opened && (after = opened.open && opened.open(next, state, context));\n          }\n        }\n\n        // Current contextual tail token (yield from sequence)\n        yield (previous = next);\n\n        // Next reference to last contextual sequence token\n        next && !whitespace && forming && (last = next);\n\n        if (after) {\n          let tokens, token, nextIndex;\n\n          if (after.syntax) {\n            const {syntax, offset, index} = after;\n            const body = index > offset && source.slice(offset, index - 1);\n            if (body) {\n              body.length > 0 &&\n                ((tokens = tokenize(body, {options: {sourceType: syntax}}, this.defaults)), (nextIndex = index));\n              const hint = `${syntax}-in-${mode.syntax}`;\n              token = token => ((token.hint = `${(token.hint && `${token.hint} `) || ''}${hint}`), token);\n            }\n          } else if (after.length) {\n            const hint = grouping.hint;\n            token = token => ((token.hint = `${hint} ${token.type || 'code'}`), context.token(token));\n            (tokens = after).end > state.index && (nextIndex = after.end);\n          }\n\n          if (tokens) {\n            for (const next of tokens) {\n              previous && ((next.previous = previous).next = next);\n              token && token(next);\n              yield (previous = next);\n            }\n            nextIndex > state.index && (state.index = nextIndex);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Context generator using tokenizer.mode (or defaults.mode)\n   */\n  get contextualizer() {\n    const value = this.constructor.contextualizer(this);\n    Object.defineProperty(this, 'contextualizer', {value});\n    return value;\n  }\n\n  /**\n   * Tokenizer context generator\n   */\n  static *contextualizer(tokenizer) {\n    // Local contextualizer state\n    let grouper, done;\n\n    // Tokenizer mode\n    const mode = tokenizer.mode;\n    const defaults = tokenizer.defaults;\n    mode !== undefined || (mode = (defaults && defaults.mode) || undefined);\n    if (!mode) throw ReferenceError(`Tokenizer.contextualizer invoked without a mode`);\n\n    // TODO: Refactoring\n    const initialize = context => {\n      context.token ||\n        (context.token = (tokenizer => (tokenizer.next(), token => tokenizer.next(token).value))(\n          this.tokenizer(context),\n        ));\n      return context;\n    };\n\n    if (!mode.context) {\n      const {\n        syntax,\n        matcher = (mode.matcher = (defaults && defaults.matcher) || undefined),\n        quotes,\n        punctuators = (mode.punctuators = {aggregators: {}}),\n        punctuators: {aggregators = ($punctuators.aggregators = {})},\n        patterns: {\n          maybeKeyword = (mode.patterns.maybeKeyword =\n            (defaults && defaults.patterns && defaults.patterns.maybeKeyword) || undefined),\n        } = (mode.patterns = {maybeKeyword: null}),\n        spans: {['(spans)']: spans} = (mode.spans = {}),\n      } = mode;\n\n      initialize(\n        (mode.context = {\n          mode,\n          punctuators,\n          aggregators,\n          matcher,\n          quotes,\n          spans,\n        }),\n      );\n    }\n\n    const {\n      syntax: $syntax,\n      matcher: $matcher,\n      quotes: $quotes,\n      punctuators: $punctuators,\n      punctuators: {aggregators: $aggregators},\n    } = mode;\n\n    while (true) {\n      if (grouper !== (grouper = yield (grouper && grouper.context) || mode.context) && grouper && !grouper.context) {\n        const {\n          goal = $syntax,\n          punctuator,\n          punctuators = $punctuators,\n          aggregators = $aggregators,\n          closer,\n          spans,\n          matcher = $matcher,\n          quotes = $quotes,\n          forming = goal === $syntax,\n        } = grouper;\n\n        initialize(\n          (grouper.context = {\n            mode,\n            punctuator,\n            punctuators,\n            aggregators,\n            closer,\n            spans,\n            matcher,\n            quotes,\n            forming,\n          }),\n        );\n      }\n    }\n  }\n\n  static *tokenizer(context) {\n    let done, next;\n\n    const {\n      mode: {syntax, keywords, assigners, operators, combinators, nonbreakers, comments, closures, breakers, patterns},\n      punctuators,\n      aggregators,\n      spans,\n      quotes,\n      forming = true,\n    } = context;\n\n    const {maybeIdentifier, maybeKeyword, segments} = patterns || false;\n    const wording = keywords || maybeIdentifier ? true : false;\n\n    const matchSegment =\n      segments &&\n      (segments[Symbol.match] ||\n        (!(Symbol.match in segments) &&\n          (segments[Symbol.match] = (segments => {\n            const sources = [];\n            const names = [];\n            for (const name of Object.getOwnPropertyNames(segments)) {\n              const segment = segments[name];\n              if (segment && segment.source && !/\\\\\\d/.test(segment.source)) {\n                names.push(name);\n                sources.push(segment.source.replace(/\\\\?\\((.)/g, (m, a) => (m[0] !== '\\\\' && a !== '?' && '(?:') || m));\n              }\n            }\n            const {length} = names;\n            if (!length) return false;\n            const matcher = new RegExp(`(${sources.join('|)|(')}|)`, 'u');\n            return text => {\n              // OR: for (const segment of names) if (segments[segment].test(text)) return segment;\n              const match = matcher.exec(text);\n              if (match[0]) for (let i = 1, n = length; n--; i++) if (match[i]) return names[i - 1];\n            };\n          })(segments))));\n\n    const LineEndings = /$/gm;\n    const punctuate = text =>\n      (nonbreakers && nonbreakers.includes(text) && 'nonbreaker') ||\n      (operators && operators.includes(text) && 'operator') ||\n      (comments && comments.includes(text) && 'comment') ||\n      (spans && spans.includes(text) && 'span') ||\n      (quotes && quotes.includes(text) && 'quote') ||\n      (closures && closures.includes(text) && 'closure') ||\n      (breakers && breakers.includes(text) && 'breaker') ||\n      false;\n    const aggregate = text =>\n      (assigners && assigners.includes(text) && 'assigner') ||\n      (combinators && combinators.includes(text) && 'combinator') ||\n      false;\n\n    while (!done) {\n      let token;\n\n      if (next && next.text) {\n        const {text, type, hint, previous, parent, last} = next;\n\n        if (type === 'sequence') {\n          ((next.punctuator =\n            (previous && (aggregators[text] || (!(text in aggregators) && (aggregators[text] = aggregate(text))))) ||\n            (punctuators[text] || (!(text in punctuators) && (punctuators[text] = punctuate(text)))) ||\n            undefined) &&\n            (next.type = 'punctuator')) ||\n            (matchSegment &&\n              (next.type = matchSegment(text)) &&\n              (next.hint = `${(hint && `${hint} `) || ''}${next.type}`)) ||\n            (next.type = 'sequence');\n        } else if (type === 'whitespace') {\n          next.breaks = text.match(LineEndings).length - 1;\n        } else if (forming && wording) {\n          const word = text.trim();\n          word &&\n            ((keywords &&\n              keywords.includes(word) &&\n              (!last || last.punctuator !== 'nonbreaker' || (previous && previous.breaks > 0)) &&\n              (next.type = 'keyword')) ||\n              (maybeIdentifier && maybeIdentifier.test(word) && (next.type = 'identifier')));\n        } else {\n          next.type = 'text';\n        }\n\n        previous && (previous.next = next) && (parent || (next.parent = previous.parent));\n\n        token = next;\n      }\n\n      next = yield token;\n    }\n  }\n\n  static createGrouper({\n    syntax,\n    goal = syntax,\n    quote,\n    comment,\n    closure,\n    span,\n    grouping = comment || closure || span || undefined,\n    punctuator,\n    spans = (grouping && grouping.spans) || undefined,\n    matcher = (grouping && grouping.matcher) || undefined,\n    quotes = (grouping && grouping.quotes) || undefined,\n    punctuators = {aggregators: {}},\n    opener = quote || (grouping && grouping.opener) || undefined,\n    closer = quote || (grouping && grouping.closer) || undefined,\n    hinter,\n    open = (grouping && grouping.open) || undefined,\n    close = (grouping && grouping.close) || undefined,\n  }) {\n    return {syntax, goal, punctuator, spans, matcher, quotes, punctuators, opener, closer, hinter, open, close};\n  }\n}\n","import {Tokenizer} from './tokenizer.mjs';\n\nexport const TOKENIZERS = 'tokenizers';\nexport const MAPPINGS = 'mappings';\nexport const MODES = 'modes';\n\nconst none = {\n  syntax: 'markup',\n  matcher: /([\\s\\n]+)|(\\\\(?:(?:\\\\\\\\)*\\\\|[^\\\\\\s])?|\\/\\/+|\\/\\*+|\\*+\\/|\\(|\\)|\\[|\\]|,|;|\\.\\.\\.|\\.|\\b:\\/\\/\\b|::|:|\\?|`|\"|'|\\$\\{|\\{|\\}|=>|<\\/|\\/>|\\++|\\-+|\\*+|&+|\\|+|=+|!={0,3}|<{1,3}=?|>{1,2}=?)|[+\\-*/&|^%<>~!]=?/g,\n};\n\nconst define = (instance, property, value, options) => {\n  if (!instance.hasOwnProperty(property))\n    return (\n      Object.defineProperty(instance, property, {\n        value,\n        writable: (options && options.writable === true) || false,\n        configurable: (options && options.configurable === true) || false,\n        enumerable: !options || options.enumerable === true,\n      }),\n      value\n    );\n};\n\nexport class Parser {\n  /**\n   * @param source {string}\n   * @param state {{sourceType?: string}}\n   */\n  tokenize(source, state = {}) {\n    const {\n      options: {\n        sourceType,\n        mode = (state.options.mode = (sourceType && this.get(sourceType)) || none),\n      } = (state.options = {}),\n    } = state;\n    let tokenizer = mode && this[TOKENIZERS].get(mode);\n    if (!source || !mode) return [];\n    !tokenizer && this[TOKENIZERS].set(mode, (tokenizer = new Tokenizer(mode)));\n    state.parser = this;\n    state.tokenize = (this.hasOwnProperty('tokenize') && this.tokenize) || (this.tokenize = this.tokenize.bind(this));\n    return tokenizer.tokenize(source, state);\n  }\n\n  get [TOKENIZERS]() {\n    return define(this, TOKENIZERS, new WeakMap());\n  }\n  get [MAPPINGS]() {\n    return define(this, MAPPINGS, Object.create(null));\n  }\n\n  get [MODES]() {\n    return define(this, MODES, Object.create(null));\n  }\n\n  get(id = 'default') {\n    const {[MAPPINGS]: mappings, [MODES]: modes} = this;\n    if (id in modes) return modes[id];\n    let mapping = mappings[id];\n    !mapping || mapping.syntax === id || (mapping = mappings[mapping.syntax]);\n    if (mapping && mapping.factory) {\n      const {syntax, factory, options} = mapping;\n      if (options.requires && options.requires.length > 0) {\n        const list = [];\n        for (const id of options.requires) id in modes || this.get(id) || list.push(id);\n        if (list.length) {\n          list.length > 1 && list.push(list.splice(-2, 2).join(' and '));\n          throw Error(`Cannot initialize \"${syntax}\" which requires the list mode(s): ${list.join(', ')}`);\n        }\n      }\n      return (mapping.mode = modes[id] = factory(options, modes));\n    }\n  }\n\n  /**\n   * @param mode {ModeFactory | Mode}\n   * @param options {ModeOptions}\n   */\n  register(mode, options) {\n    const {[MAPPINGS]: mappings, [MODES]: modes} = this;\n\n    if (!mappings) return;\n\n    const factory = typeof mode === 'function' && mode;\n\n    const {syntax, aliases = (options.aliases = [])} = ({syntax: options.syntax = mode.syntax} = options = {\n      syntax: undefined,\n      ...factory.defaults,\n      ...options,\n    });\n\n    if (!syntax || typeof syntax !== 'string')\n      throw TypeError(`Cannot register \"${syntax}\" since it not valid string'`);\n\n    if (mappings[syntax]) {\n      if (factory ? factory === mappings[syntax].factory : mode === modes[syntax]) return;\n      else throw ReferenceError(`Cannot register \"${syntax}\" since it is already registered`);\n    }\n\n    if (aliases && aliases.length > 0) {\n      for (const alias of aliases) {\n        if (!alias || typeof alias !== 'string')\n          throw TypeError(`Cannot register \"${syntax}\" since it's alias \"${alias}\" not valid string'`);\n        else if (mappings[alias])\n          throw ReferenceError(`Cannot register \"${syntax}\" since it's alias \"${alias}\" is already registered`);\n      }\n    }\n\n    const mapping = factory ? {syntax, factory, options} : {syntax, mode, options};\n\n    const descriptor = {value: mapping, writable: false};\n    for (const id of [syntax, ...aliases]) {\n      Object.defineProperty(mappings, id, descriptor);\n    }\n  }\n\n  /**\n   * @param mode {string}\n   * @param requires {string[]}\n   */\n  requires(mode, requires) {\n    const missing = [];\n    for (const mode of requires) mode in this[MAPPINGS] || missing.push(`\"${mode}\"`);\n    if (!missing.length) return;\n    throw Error(`Cannot initialize \"${mode}\" which requires the missing mode(s): ${missing.join(', ')}`);\n  }\n}\n\n/**\n * @typedef { Partial<{syntax: string, matcher: RegExp, [name:string]: Set | Map | {[name:string]: Set | Map | RegExp} }> } Mode\n * @typedef { {[name: string]: Mode} } Modes\n * @typedef { {[name: string]: {syntax: string} } } Mappings\n * @typedef { {aliases?: string[], syntax: string} } ModeOptions\n * @typedef { (options: ModeOptions, modes: Modes) => Mode } ModeFactory\n */\n\n// * @typedef { typeof helpers } Helpers\n"],"names":[],"mappings":"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"}